#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: RigVM

#include "Basic.hpp"


namespace SDK
{

// Enum RigVM.ERigVMParameterType
// NumValues: 0x0004
enum class ERigVMParameterType : uint8
{
	Input                                    = 0,
	Output                                   = 1,
	Invalid                                  = 2,
	ERigVMParameterType_MAX                  = 3,
};

// Enum RigVM.ERigVMOpCode
// NumValues: 0x0053
enum class ERigVMOpCode : uint8
{
	Execute_0_Operands                       = 0,
	Execute_1_Operands                       = 1,
	Execute_2_Operands                       = 2,
	Execute_3_Operands                       = 3,
	Execute_4_Operands                       = 4,
	Execute_5_Operands                       = 5,
	Execute_6_Operands                       = 6,
	Execute_7_Operands                       = 7,
	Execute_8_Operands                       = 8,
	Execute_9_Operands                       = 9,
	Execute_10_Operands                      = 10,
	Execute_11_Operands                      = 11,
	Execute_12_Operands                      = 12,
	Execute_13_Operands                      = 13,
	Execute_14_Operands                      = 14,
	Execute_15_Operands                      = 15,
	Execute_16_Operands                      = 16,
	Execute_17_Operands                      = 17,
	Execute_18_Operands                      = 18,
	Execute_19_Operands                      = 19,
	Execute_20_Operands                      = 20,
	Execute_21_Operands                      = 21,
	Execute_22_Operands                      = 22,
	Execute_23_Operands                      = 23,
	Execute_24_Operands                      = 24,
	Execute_25_Operands                      = 25,
	Execute_26_Operands                      = 26,
	Execute_27_Operands                      = 27,
	Execute_28_Operands                      = 28,
	Execute_29_Operands                      = 29,
	Execute_30_Operands                      = 30,
	Execute_31_Operands                      = 31,
	Execute_32_Operands                      = 32,
	Execute_33_Operands                      = 33,
	Execute_34_Operands                      = 34,
	Execute_35_Operands                      = 35,
	Execute_36_Operands                      = 36,
	Execute_37_Operands                      = 37,
	Execute_38_Operands                      = 38,
	Execute_39_Operands                      = 39,
	Execute_40_Operands                      = 40,
	Execute_41_Operands                      = 41,
	Execute_42_Operands                      = 42,
	Execute_43_Operands                      = 43,
	Execute_44_Operands                      = 44,
	Execute_45_Operands                      = 45,
	Execute_46_Operands                      = 46,
	Execute_47_Operands                      = 47,
	Execute_48_Operands                      = 48,
	Execute_49_Operands                      = 49,
	Execute_50_Operands                      = 50,
	Execute_51_Operands                      = 51,
	Execute_52_Operands                      = 52,
	Execute_53_Operands                      = 53,
	Execute_54_Operands                      = 54,
	Execute_55_Operands                      = 55,
	Execute_56_Operands                      = 56,
	Execute_57_Operands                      = 57,
	Execute_58_Operands                      = 58,
	Execute_59_Operands                      = 59,
	Execute_60_Operands                      = 60,
	Execute_61_Operands                      = 61,
	Execute_62_Operands                      = 62,
	Execute_63_Operands                      = 63,
	Execute_64_Operands                      = 64,
	Zero                                     = 65,
	BoolFalse                                = 66,
	BoolTrue                                 = 67,
	Copy                                     = 68,
	Increment                                = 69,
	Decrement                                = 70,
	Equals                                   = 71,
	NotEquals                                = 72,
	JumpAbsolute                             = 73,
	JumpForward                              = 74,
	JumpBackward                             = 75,
	JumpAbsoluteIf                           = 76,
	JumpForwardIf                            = 77,
	JumpBackwardIf                           = 78,
	ChangeType                               = 79,
	Exit                                     = 80,
	Invalid                                  = 81,
	ERigVMOpCode_MAX                         = 82,
};

// Enum RigVM.ERigVMRegisterType
// NumValues: 0x0006
enum class ERigVMRegisterType : uint8
{
	Plain                                    = 0,
	String                                   = 1,
	Name                                     = 2,
	Struct                                   = 3,
	Invalid                                  = 4,
	ERigVMRegisterType_MAX                   = 5,
};

// Enum RigVM.ERigVMMemoryType
// NumValues: 0x0004
enum class ERigVMMemoryType : uint8
{
	Work                                     = 0,
	Literal                                  = 1,
	Invalid                                  = 2,
	ERigVMMemoryType_MAX                     = 3,
};

// ScriptStruct RigVM.RigVMParameter
// 0x0030 (0x0030 - 0x0000)
struct FRigVMParameter final
{
public:
	ERigVMParameterType                           Type;                                              // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   Name;                                              // 0x0004(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         RegisterIndex;                                     // 0x000C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FString                                 CPPType;                                           // 0x0010(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UScriptStruct*                          ScriptStruct;                                      // 0x0020(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   ScriptStructPath;                                  // 0x0028(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
};
static_assert(alignof(FRigVMParameter) == 0x000008, "Wrong alignment on FRigVMParameter");
static_assert(sizeof(FRigVMParameter) == 0x000030, "Wrong size on FRigVMParameter");
static_assert(offsetof(FRigVMParameter, Type) == 0x000000, "Member 'FRigVMParameter::Type' has a wrong offset!");
static_assert(offsetof(FRigVMParameter, Name) == 0x000004, "Member 'FRigVMParameter::Name' has a wrong offset!");
static_assert(offsetof(FRigVMParameter, RegisterIndex) == 0x00000C, "Member 'FRigVMParameter::RegisterIndex' has a wrong offset!");
static_assert(offsetof(FRigVMParameter, CPPType) == 0x000010, "Member 'FRigVMParameter::CPPType' has a wrong offset!");
static_assert(offsetof(FRigVMParameter, ScriptStruct) == 0x000020, "Member 'FRigVMParameter::ScriptStruct' has a wrong offset!");
static_assert(offsetof(FRigVMParameter, ScriptStructPath) == 0x000028, "Member 'FRigVMParameter::ScriptStructPath' has a wrong offset!");

// ScriptStruct RigVM.RigVMByteCode
// 0x0010 (0x0010 - 0x0000)
struct FRigVMByteCode final
{
public:
	TArray<uint8>                                 ByteCode;                                          // 0x0000(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
};
static_assert(alignof(FRigVMByteCode) == 0x000008, "Wrong alignment on FRigVMByteCode");
static_assert(sizeof(FRigVMByteCode) == 0x000010, "Wrong size on FRigVMByteCode");
static_assert(offsetof(FRigVMByteCode, ByteCode) == 0x000000, "Member 'FRigVMByteCode::ByteCode' has a wrong offset!");

// ScriptStruct RigVM.RigVMInstruction
// 0x0010 (0x0010 - 0x0000)
struct FRigVMInstruction final
{
public:
	ERigVMOpCode                                  OpCode;                                            // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	uint64                                        ByteCodeIndex;                                     // 0x0008(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRigVMInstruction) == 0x000008, "Wrong alignment on FRigVMInstruction");
static_assert(sizeof(FRigVMInstruction) == 0x000010, "Wrong size on FRigVMInstruction");
static_assert(offsetof(FRigVMInstruction, OpCode) == 0x000000, "Member 'FRigVMInstruction::OpCode' has a wrong offset!");
static_assert(offsetof(FRigVMInstruction, ByteCodeIndex) == 0x000008, "Member 'FRigVMInstruction::ByteCodeIndex' has a wrong offset!");

// ScriptStruct RigVM.RigVMInstructionArray
// 0x0010 (0x0010 - 0x0000)
struct FRigVMInstructionArray final
{
public:
	TArray<struct FRigVMInstruction>              Instructions;                                      // 0x0000(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
};
static_assert(alignof(FRigVMInstructionArray) == 0x000008, "Wrong alignment on FRigVMInstructionArray");
static_assert(sizeof(FRigVMInstructionArray) == 0x000010, "Wrong size on FRigVMInstructionArray");
static_assert(offsetof(FRigVMInstructionArray, Instructions) == 0x000000, "Member 'FRigVMInstructionArray::Instructions' has a wrong offset!");

// ScriptStruct RigVM.RigVMExecuteContext
// 0x0010 (0x0010 - 0x0000)
struct alignas(0x08) FRigVMExecuteContext final
{
public:
	uint8                                         Pad_0[0x10];                                       // 0x0000(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRigVMExecuteContext) == 0x000008, "Wrong alignment on FRigVMExecuteContext");
static_assert(sizeof(FRigVMExecuteContext) == 0x000010, "Wrong size on FRigVMExecuteContext");

// ScriptStruct RigVM.RigVMRegister
// 0x0020 (0x0020 - 0x0000)
struct FRigVMRegister final
{
public:
	ERigVMRegisterType                            Type;                                              // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	uint32                                        ByteIndex;                                         // 0x0004(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint16                                        ElementSize;                                       // 0x0008(0x0002)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint16                                        ElementCount;                                      // 0x000A(0x0002)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint16                                        SliceIndex;                                        // 0x000C(0x0002)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint16                                        SliceCount;                                        // 0x000E(0x0002)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         AlignmentBytes;                                    // 0x0010(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x1];                                       // 0x0011(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	uint16                                        TrailingBytes;                                     // 0x0012(0x0002)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Name;                                              // 0x0014(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ScriptStructIndex;                                 // 0x001C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRigVMRegister) == 0x000004, "Wrong alignment on FRigVMRegister");
static_assert(sizeof(FRigVMRegister) == 0x000020, "Wrong size on FRigVMRegister");
static_assert(offsetof(FRigVMRegister, Type) == 0x000000, "Member 'FRigVMRegister::Type' has a wrong offset!");
static_assert(offsetof(FRigVMRegister, ByteIndex) == 0x000004, "Member 'FRigVMRegister::ByteIndex' has a wrong offset!");
static_assert(offsetof(FRigVMRegister, ElementSize) == 0x000008, "Member 'FRigVMRegister::ElementSize' has a wrong offset!");
static_assert(offsetof(FRigVMRegister, ElementCount) == 0x00000A, "Member 'FRigVMRegister::ElementCount' has a wrong offset!");
static_assert(offsetof(FRigVMRegister, SliceIndex) == 0x00000C, "Member 'FRigVMRegister::SliceIndex' has a wrong offset!");
static_assert(offsetof(FRigVMRegister, SliceCount) == 0x00000E, "Member 'FRigVMRegister::SliceCount' has a wrong offset!");
static_assert(offsetof(FRigVMRegister, AlignmentBytes) == 0x000010, "Member 'FRigVMRegister::AlignmentBytes' has a wrong offset!");
static_assert(offsetof(FRigVMRegister, TrailingBytes) == 0x000012, "Member 'FRigVMRegister::TrailingBytes' has a wrong offset!");
static_assert(offsetof(FRigVMRegister, Name) == 0x000014, "Member 'FRigVMRegister::Name' has a wrong offset!");
static_assert(offsetof(FRigVMRegister, ScriptStructIndex) == 0x00001C, "Member 'FRigVMRegister::ScriptStructIndex' has a wrong offset!");

// ScriptStruct RigVM.RigVMRegisterOffset
// 0x0038 (0x0038 - 0x0000)
struct FRigVMRegisterOffset final
{
public:
	TArray<int32>                                 Segments;                                          // 0x0000(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	ERigVMRegisterType                            Type;                                              // 0x0010(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_11[0x3];                                       // 0x0011(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   CPPType;                                           // 0x0014(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UScriptStruct*                          ScriptStruct;                                      // 0x0020(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   ScriptStructPath;                                  // 0x0028(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint16                                        ElementSize;                                       // 0x0030(0x0002)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_32[0x6];                                       // 0x0032(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRigVMRegisterOffset) == 0x000008, "Wrong alignment on FRigVMRegisterOffset");
static_assert(sizeof(FRigVMRegisterOffset) == 0x000038, "Wrong size on FRigVMRegisterOffset");
static_assert(offsetof(FRigVMRegisterOffset, Segments) == 0x000000, "Member 'FRigVMRegisterOffset::Segments' has a wrong offset!");
static_assert(offsetof(FRigVMRegisterOffset, Type) == 0x000010, "Member 'FRigVMRegisterOffset::Type' has a wrong offset!");
static_assert(offsetof(FRigVMRegisterOffset, CPPType) == 0x000014, "Member 'FRigVMRegisterOffset::CPPType' has a wrong offset!");
static_assert(offsetof(FRigVMRegisterOffset, ScriptStruct) == 0x000020, "Member 'FRigVMRegisterOffset::ScriptStruct' has a wrong offset!");
static_assert(offsetof(FRigVMRegisterOffset, ScriptStructPath) == 0x000028, "Member 'FRigVMRegisterOffset::ScriptStructPath' has a wrong offset!");
static_assert(offsetof(FRigVMRegisterOffset, ElementSize) == 0x000030, "Member 'FRigVMRegisterOffset::ElementSize' has a wrong offset!");

// ScriptStruct RigVM.RigVMMemoryContainer
// 0x0098 (0x0098 - 0x0000)
struct FRigVMMemoryContainer final
{
public:
	bool                                          bUseNameMap;                                       // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	ERigVMMemoryType                              MemoryType;                                        // 0x0001(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2[0x6];                                        // 0x0002(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FRigVMRegister>                 Registers;                                         // 0x0008(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<struct FRigVMRegisterOffset>           RegisterOffsets;                                   // 0x0018(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<uint8>                                 Data;                                              // 0x0028(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	TArray<class UScriptStruct*>                  ScriptStructs;                                     // 0x0038(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	TMap<class FName, int32>                      NameMap;                                           // 0x0048(0x0050)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
};
static_assert(alignof(FRigVMMemoryContainer) == 0x000008, "Wrong alignment on FRigVMMemoryContainer");
static_assert(sizeof(FRigVMMemoryContainer) == 0x000098, "Wrong size on FRigVMMemoryContainer");
static_assert(offsetof(FRigVMMemoryContainer, bUseNameMap) == 0x000000, "Member 'FRigVMMemoryContainer::bUseNameMap' has a wrong offset!");
static_assert(offsetof(FRigVMMemoryContainer, MemoryType) == 0x000001, "Member 'FRigVMMemoryContainer::MemoryType' has a wrong offset!");
static_assert(offsetof(FRigVMMemoryContainer, Registers) == 0x000008, "Member 'FRigVMMemoryContainer::Registers' has a wrong offset!");
static_assert(offsetof(FRigVMMemoryContainer, RegisterOffsets) == 0x000018, "Member 'FRigVMMemoryContainer::RegisterOffsets' has a wrong offset!");
static_assert(offsetof(FRigVMMemoryContainer, Data) == 0x000028, "Member 'FRigVMMemoryContainer::Data' has a wrong offset!");
static_assert(offsetof(FRigVMMemoryContainer, ScriptStructs) == 0x000038, "Member 'FRigVMMemoryContainer::ScriptStructs' has a wrong offset!");
static_assert(offsetof(FRigVMMemoryContainer, NameMap) == 0x000048, "Member 'FRigVMMemoryContainer::NameMap' has a wrong offset!");

}

