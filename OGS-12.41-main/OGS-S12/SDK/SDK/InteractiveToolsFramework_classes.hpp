#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: InteractiveToolsFramework

#include "Basic.hpp"

#include "Engine_classes.hpp"
#include "CoreUObject_structs.hpp"
#include "CoreUObject_classes.hpp"
#include "InteractiveToolsFramework_structs.hpp"


namespace SDK
{

// Class InteractiveToolsFramework.InputBehavior
// 0x0008 (0x0030 - 0x0028)
class UInputBehavior : public UObject
{
public:
	uint8                                         Pad_28[0x8];                                       // 0x0028(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InputBehavior">();
	}
	static class UInputBehavior* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInputBehavior>();
	}
};
static_assert(alignof(UInputBehavior) == 0x000008, "Wrong alignment on UInputBehavior");
static_assert(sizeof(UInputBehavior) == 0x000030, "Wrong size on UInputBehavior");

// Class InteractiveToolsFramework.AnyButtonInputBehavior
// 0x0008 (0x0038 - 0x0030)
class UAnyButtonInputBehavior : public UInputBehavior
{
public:
	int32                                         ButtonNumber;                                      // 0x0030(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnyButtonInputBehavior">();
	}
	static class UAnyButtonInputBehavior* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnyButtonInputBehavior>();
	}
};
static_assert(alignof(UAnyButtonInputBehavior) == 0x000008, "Wrong alignment on UAnyButtonInputBehavior");
static_assert(sizeof(UAnyButtonInputBehavior) == 0x000038, "Wrong size on UAnyButtonInputBehavior");
static_assert(offsetof(UAnyButtonInputBehavior, ButtonNumber) == 0x000030, "Member 'UAnyButtonInputBehavior::ButtonNumber' has a wrong offset!");

// Class InteractiveToolsFramework.InteractiveGizmoBuilder
// 0x0000 (0x0028 - 0x0028)
class UInteractiveGizmoBuilder : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InteractiveGizmoBuilder">();
	}
	static class UInteractiveGizmoBuilder* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInteractiveGizmoBuilder>();
	}
};
static_assert(alignof(UInteractiveGizmoBuilder) == 0x000008, "Wrong alignment on UInteractiveGizmoBuilder");
static_assert(sizeof(UInteractiveGizmoBuilder) == 0x000028, "Wrong size on UInteractiveGizmoBuilder");

// Class InteractiveToolsFramework.AxisAngleGizmoBuilder
// 0x0000 (0x0028 - 0x0028)
class UAxisAngleGizmoBuilder final : public UInteractiveGizmoBuilder
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AxisAngleGizmoBuilder">();
	}
	static class UAxisAngleGizmoBuilder* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAxisAngleGizmoBuilder>();
	}
};
static_assert(alignof(UAxisAngleGizmoBuilder) == 0x000008, "Wrong alignment on UAxisAngleGizmoBuilder");
static_assert(sizeof(UAxisAngleGizmoBuilder) == 0x000028, "Wrong size on UAxisAngleGizmoBuilder");

// Class InteractiveToolsFramework.InteractiveGizmo
// 0x0010 (0x0038 - 0x0028)
class UInteractiveGizmo : public UObject
{
public:
	uint8                                         Pad_28[0x8];                                       // 0x0028(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UInputBehaviorSet*                      InputBehaviors;                                    // 0x0030(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InteractiveGizmo">();
	}
	static class UInteractiveGizmo* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInteractiveGizmo>();
	}
};
static_assert(alignof(UInteractiveGizmo) == 0x000008, "Wrong alignment on UInteractiveGizmo");
static_assert(sizeof(UInteractiveGizmo) == 0x000038, "Wrong size on UInteractiveGizmo");
static_assert(offsetof(UInteractiveGizmo, InputBehaviors) == 0x000030, "Member 'UInteractiveGizmo::InputBehaviors' has a wrong offset!");

// Class InteractiveToolsFramework.AxisAngleGizmo
// 0x00B8 (0x00F0 - 0x0038)
class UAxisAngleGizmo final : public UInteractiveGizmo
{
public:
	uint8                                         Pad_38[0x10];                                      // 0x0038(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TScriptInterface<class IGizmoAxisSource>      AxisSource;                                        // 0x0048(0x0010)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, NativeAccessSpecifierPublic)
	TScriptInterface<class IGizmoFloatParameterSource> AngleSource;                                       // 0x0058(0x0010)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, NativeAccessSpecifierPublic)
	TScriptInterface<class IGizmoClickTarget>     HitTarget;                                         // 0x0068(0x0010)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, NativeAccessSpecifierPublic)
	TScriptInterface<class IGizmoStateTarget>     StateTarget;                                       // 0x0078(0x0010)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, NativeAccessSpecifierPublic)
	bool                                          bInInteraction;                                    // 0x0088(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_89[0x3];                                       // 0x0089(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                RotationOrigin;                                    // 0x008C(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                RotationAxis;                                      // 0x0098(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                RotationPlaneX;                                    // 0x00A4(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                RotationPlaneY;                                    // 0x00B0(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                InteractionStartPoint;                             // 0x00BC(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                InteractionCurPoint;                               // 0x00C8(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InteractionStartAngle;                             // 0x00D4(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InteractionCurAngle;                               // 0x00D8(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_DC[0x14];                                      // 0x00DC(0x0014)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AxisAngleGizmo">();
	}
	static class UAxisAngleGizmo* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAxisAngleGizmo>();
	}
};
static_assert(alignof(UAxisAngleGizmo) == 0x000008, "Wrong alignment on UAxisAngleGizmo");
static_assert(sizeof(UAxisAngleGizmo) == 0x0000F0, "Wrong size on UAxisAngleGizmo");
static_assert(offsetof(UAxisAngleGizmo, AxisSource) == 0x000048, "Member 'UAxisAngleGizmo::AxisSource' has a wrong offset!");
static_assert(offsetof(UAxisAngleGizmo, AngleSource) == 0x000058, "Member 'UAxisAngleGizmo::AngleSource' has a wrong offset!");
static_assert(offsetof(UAxisAngleGizmo, HitTarget) == 0x000068, "Member 'UAxisAngleGizmo::HitTarget' has a wrong offset!");
static_assert(offsetof(UAxisAngleGizmo, StateTarget) == 0x000078, "Member 'UAxisAngleGizmo::StateTarget' has a wrong offset!");
static_assert(offsetof(UAxisAngleGizmo, bInInteraction) == 0x000088, "Member 'UAxisAngleGizmo::bInInteraction' has a wrong offset!");
static_assert(offsetof(UAxisAngleGizmo, RotationOrigin) == 0x00008C, "Member 'UAxisAngleGizmo::RotationOrigin' has a wrong offset!");
static_assert(offsetof(UAxisAngleGizmo, RotationAxis) == 0x000098, "Member 'UAxisAngleGizmo::RotationAxis' has a wrong offset!");
static_assert(offsetof(UAxisAngleGizmo, RotationPlaneX) == 0x0000A4, "Member 'UAxisAngleGizmo::RotationPlaneX' has a wrong offset!");
static_assert(offsetof(UAxisAngleGizmo, RotationPlaneY) == 0x0000B0, "Member 'UAxisAngleGizmo::RotationPlaneY' has a wrong offset!");
static_assert(offsetof(UAxisAngleGizmo, InteractionStartPoint) == 0x0000BC, "Member 'UAxisAngleGizmo::InteractionStartPoint' has a wrong offset!");
static_assert(offsetof(UAxisAngleGizmo, InteractionCurPoint) == 0x0000C8, "Member 'UAxisAngleGizmo::InteractionCurPoint' has a wrong offset!");
static_assert(offsetof(UAxisAngleGizmo, InteractionStartAngle) == 0x0000D4, "Member 'UAxisAngleGizmo::InteractionStartAngle' has a wrong offset!");
static_assert(offsetof(UAxisAngleGizmo, InteractionCurAngle) == 0x0000D8, "Member 'UAxisAngleGizmo::InteractionCurAngle' has a wrong offset!");

// Class InteractiveToolsFramework.AxisPositionGizmoBuilder
// 0x0000 (0x0028 - 0x0028)
class UAxisPositionGizmoBuilder final : public UInteractiveGizmoBuilder
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AxisPositionGizmoBuilder">();
	}
	static class UAxisPositionGizmoBuilder* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAxisPositionGizmoBuilder>();
	}
};
static_assert(alignof(UAxisPositionGizmoBuilder) == 0x000008, "Wrong alignment on UAxisPositionGizmoBuilder");
static_assert(sizeof(UAxisPositionGizmoBuilder) == 0x000028, "Wrong size on UAxisPositionGizmoBuilder");

// Class InteractiveToolsFramework.AxisPositionGizmo
// 0x00A0 (0x00D8 - 0x0038)
class UAxisPositionGizmo final : public UInteractiveGizmo
{
public:
	uint8                                         Pad_38[0x10];                                      // 0x0038(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TScriptInterface<class IGizmoAxisSource>      AxisSource;                                        // 0x0048(0x0010)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, NativeAccessSpecifierPublic)
	TScriptInterface<class IGizmoFloatParameterSource> ParameterSource;                                   // 0x0058(0x0010)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, NativeAccessSpecifierPublic)
	TScriptInterface<class IGizmoClickTarget>     HitTarget;                                         // 0x0068(0x0010)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, NativeAccessSpecifierPublic)
	TScriptInterface<class IGizmoStateTarget>     StateTarget;                                       // 0x0078(0x0010)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, NativeAccessSpecifierPublic)
	bool                                          bInInteraction;                                    // 0x0088(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_89[0x3];                                       // 0x0089(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                InteractionOrigin;                                 // 0x008C(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                InteractionAxis;                                   // 0x0098(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                InteractionStartPoint;                             // 0x00A4(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                InteractionCurPoint;                               // 0x00B0(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InteractionStartParameter;                         // 0x00BC(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InteractionCurParameter;                           // 0x00C0(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C4[0x14];                                      // 0x00C4(0x0014)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AxisPositionGizmo">();
	}
	static class UAxisPositionGizmo* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAxisPositionGizmo>();
	}
};
static_assert(alignof(UAxisPositionGizmo) == 0x000008, "Wrong alignment on UAxisPositionGizmo");
static_assert(sizeof(UAxisPositionGizmo) == 0x0000D8, "Wrong size on UAxisPositionGizmo");
static_assert(offsetof(UAxisPositionGizmo, AxisSource) == 0x000048, "Member 'UAxisPositionGizmo::AxisSource' has a wrong offset!");
static_assert(offsetof(UAxisPositionGizmo, ParameterSource) == 0x000058, "Member 'UAxisPositionGizmo::ParameterSource' has a wrong offset!");
static_assert(offsetof(UAxisPositionGizmo, HitTarget) == 0x000068, "Member 'UAxisPositionGizmo::HitTarget' has a wrong offset!");
static_assert(offsetof(UAxisPositionGizmo, StateTarget) == 0x000078, "Member 'UAxisPositionGizmo::StateTarget' has a wrong offset!");
static_assert(offsetof(UAxisPositionGizmo, bInInteraction) == 0x000088, "Member 'UAxisPositionGizmo::bInInteraction' has a wrong offset!");
static_assert(offsetof(UAxisPositionGizmo, InteractionOrigin) == 0x00008C, "Member 'UAxisPositionGizmo::InteractionOrigin' has a wrong offset!");
static_assert(offsetof(UAxisPositionGizmo, InteractionAxis) == 0x000098, "Member 'UAxisPositionGizmo::InteractionAxis' has a wrong offset!");
static_assert(offsetof(UAxisPositionGizmo, InteractionStartPoint) == 0x0000A4, "Member 'UAxisPositionGizmo::InteractionStartPoint' has a wrong offset!");
static_assert(offsetof(UAxisPositionGizmo, InteractionCurPoint) == 0x0000B0, "Member 'UAxisPositionGizmo::InteractionCurPoint' has a wrong offset!");
static_assert(offsetof(UAxisPositionGizmo, InteractionStartParameter) == 0x0000BC, "Member 'UAxisPositionGizmo::InteractionStartParameter' has a wrong offset!");
static_assert(offsetof(UAxisPositionGizmo, InteractionCurParameter) == 0x0000C0, "Member 'UAxisPositionGizmo::InteractionCurParameter' has a wrong offset!");

// Class InteractiveToolsFramework.GizmoConstantAxisSource
// 0x0020 (0x0048 - 0x0028)
class UGizmoConstantAxisSource final : public UObject
{
public:
	uint8                                         Pad_28[0x8];                                       // 0x0028(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                Origin;                                            // 0x0030(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Direction;                                         // 0x003C(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GizmoConstantAxisSource">();
	}
	static class UGizmoConstantAxisSource* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGizmoConstantAxisSource>();
	}
};
static_assert(alignof(UGizmoConstantAxisSource) == 0x000008, "Wrong alignment on UGizmoConstantAxisSource");
static_assert(sizeof(UGizmoConstantAxisSource) == 0x000048, "Wrong size on UGizmoConstantAxisSource");
static_assert(offsetof(UGizmoConstantAxisSource, Origin) == 0x000030, "Member 'UGizmoConstantAxisSource::Origin' has a wrong offset!");
static_assert(offsetof(UGizmoConstantAxisSource, Direction) == 0x00003C, "Member 'UGizmoConstantAxisSource::Direction' has a wrong offset!");

// Class InteractiveToolsFramework.GizmoWorldAxisSource
// 0x0018 (0x0040 - 0x0028)
class UGizmoWorldAxisSource final : public UObject
{
public:
	uint8                                         Pad_28[0x8];                                       // 0x0028(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                Origin;                                            // 0x0030(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         AxisIndex;                                         // 0x003C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GizmoWorldAxisSource">();
	}
	static class UGizmoWorldAxisSource* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGizmoWorldAxisSource>();
	}
};
static_assert(alignof(UGizmoWorldAxisSource) == 0x000008, "Wrong alignment on UGizmoWorldAxisSource");
static_assert(sizeof(UGizmoWorldAxisSource) == 0x000040, "Wrong size on UGizmoWorldAxisSource");
static_assert(offsetof(UGizmoWorldAxisSource, Origin) == 0x000030, "Member 'UGizmoWorldAxisSource::Origin' has a wrong offset!");
static_assert(offsetof(UGizmoWorldAxisSource, AxisIndex) == 0x00003C, "Member 'UGizmoWorldAxisSource::AxisIndex' has a wrong offset!");

// Class InteractiveToolsFramework.GizmoComponentAxisSource
// 0x0018 (0x0040 - 0x0028)
class UGizmoComponentAxisSource final : public UObject
{
public:
	uint8                                         Pad_28[0x8];                                       // 0x0028(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class USceneComponent*                        Component;                                         // 0x0030(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         AxisIndex;                                         // 0x0038(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLocalAxes;                                        // 0x003C(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3D[0x3];                                       // 0x003D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GizmoComponentAxisSource">();
	}
	static class UGizmoComponentAxisSource* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGizmoComponentAxisSource>();
	}
};
static_assert(alignof(UGizmoComponentAxisSource) == 0x000008, "Wrong alignment on UGizmoComponentAxisSource");
static_assert(sizeof(UGizmoComponentAxisSource) == 0x000040, "Wrong size on UGizmoComponentAxisSource");
static_assert(offsetof(UGizmoComponentAxisSource, Component) == 0x000030, "Member 'UGizmoComponentAxisSource::Component' has a wrong offset!");
static_assert(offsetof(UGizmoComponentAxisSource, AxisIndex) == 0x000038, "Member 'UGizmoComponentAxisSource::AxisIndex' has a wrong offset!");
static_assert(offsetof(UGizmoComponentAxisSource, bLocalAxes) == 0x00003C, "Member 'UGizmoComponentAxisSource::bLocalAxes' has a wrong offset!");

// Class InteractiveToolsFramework.ClickDragInputBehavior
// 0x00B8 (0x00F0 - 0x0038)
class UClickDragInputBehavior final : public UAnyButtonInputBehavior
{
public:
	uint8                                         Pad_38[0xB8];                                      // 0x0038(0x00B8)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ClickDragInputBehavior">();
	}
	static class UClickDragInputBehavior* GetDefaultObj()
	{
		return GetDefaultObjImpl<UClickDragInputBehavior>();
	}
};
static_assert(alignof(UClickDragInputBehavior) == 0x000008, "Wrong alignment on UClickDragInputBehavior");
static_assert(sizeof(UClickDragInputBehavior) == 0x0000F0, "Wrong size on UClickDragInputBehavior");

// Class InteractiveToolsFramework.InteractiveToolBuilder
// 0x0000 (0x0028 - 0x0028)
class UInteractiveToolBuilder : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InteractiveToolBuilder">();
	}
	static class UInteractiveToolBuilder* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInteractiveToolBuilder>();
	}
};
static_assert(alignof(UInteractiveToolBuilder) == 0x000008, "Wrong alignment on UInteractiveToolBuilder");
static_assert(sizeof(UInteractiveToolBuilder) == 0x000028, "Wrong size on UInteractiveToolBuilder");

// Class InteractiveToolsFramework.ClickDragToolBuilder
// 0x0000 (0x0028 - 0x0028)
class UClickDragToolBuilder final : public UInteractiveToolBuilder
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ClickDragToolBuilder">();
	}
	static class UClickDragToolBuilder* GetDefaultObj()
	{
		return GetDefaultObjImpl<UClickDragToolBuilder>();
	}
};
static_assert(alignof(UClickDragToolBuilder) == 0x000008, "Wrong alignment on UClickDragToolBuilder");
static_assert(sizeof(UClickDragToolBuilder) == 0x000028, "Wrong size on UClickDragToolBuilder");

// Class InteractiveToolsFramework.InteractiveTool
// 0x0028 (0x0050 - 0x0028)
class UInteractiveTool : public UObject
{
public:
	uint8                                         Pad_28[0x8];                                       // 0x0028(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UInputBehaviorSet*                      InputBehaviors;                                    // 0x0030(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UObject*>                        ToolPropertyObjects;                               // 0x0038(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_48[0x8];                                       // 0x0048(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InteractiveTool">();
	}
	static class UInteractiveTool* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInteractiveTool>();
	}
};
static_assert(alignof(UInteractiveTool) == 0x000008, "Wrong alignment on UInteractiveTool");
static_assert(sizeof(UInteractiveTool) == 0x000050, "Wrong size on UInteractiveTool");
static_assert(offsetof(UInteractiveTool, InputBehaviors) == 0x000030, "Member 'UInteractiveTool::InputBehaviors' has a wrong offset!");
static_assert(offsetof(UInteractiveTool, ToolPropertyObjects) == 0x000038, "Member 'UInteractiveTool::ToolPropertyObjects' has a wrong offset!");

// Class InteractiveToolsFramework.ClickDragTool
// 0x0008 (0x0058 - 0x0050)
class UClickDragTool final : public UInteractiveTool
{
public:
	uint8                                         Pad_50[0x8];                                       // 0x0050(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ClickDragTool">();
	}
	static class UClickDragTool* GetDefaultObj()
	{
		return GetDefaultObjImpl<UClickDragTool>();
	}
};
static_assert(alignof(UClickDragTool) == 0x000008, "Wrong alignment on UClickDragTool");
static_assert(sizeof(UClickDragTool) == 0x000058, "Wrong size on UClickDragTool");

// Class InteractiveToolsFramework.InternalToolFrameworkActor
// 0x0000 (0x0218 - 0x0218)
class AInternalToolFrameworkActor : public AActor
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InternalToolFrameworkActor">();
	}
	static class AInternalToolFrameworkActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AInternalToolFrameworkActor>();
	}
};
static_assert(alignof(AInternalToolFrameworkActor) == 0x000008, "Wrong alignment on AInternalToolFrameworkActor");
static_assert(sizeof(AInternalToolFrameworkActor) == 0x000218, "Wrong size on AInternalToolFrameworkActor");

// Class InteractiveToolsFramework.GizmoActor
// 0x0000 (0x0218 - 0x0218)
class AGizmoActor : public AInternalToolFrameworkActor
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GizmoActor">();
	}
	static class AGizmoActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGizmoActor>();
	}
};
static_assert(alignof(AGizmoActor) == 0x000008, "Wrong alignment on AGizmoActor");
static_assert(sizeof(AGizmoActor) == 0x000218, "Wrong size on AGizmoActor");

// Class InteractiveToolsFramework.GizmoBaseComponent
// 0x0020 (0x0410 - 0x03F0)
#pragma pack(push, 0x1)
class alignas(0x10) UGizmoBaseComponent : public UPrimitiveComponent
{
public:
	struct FLinearColor                           Color;                                             // 0x03E8(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HoverSizeMultiplier;                               // 0x03F8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PixelHitDistanceThreshold;                         // 0x03FC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_400[0x8];                                      // 0x0400(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void UpdateHoverState(bool bHoveringIn);
	void UpdateWorldLocalState(bool bWorldIn);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GizmoBaseComponent">();
	}
	static class UGizmoBaseComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGizmoBaseComponent>();
	}
};
#pragma pack(pop)
static_assert(alignof(UGizmoBaseComponent) == 0x000010, "Wrong alignment on UGizmoBaseComponent");
static_assert(sizeof(UGizmoBaseComponent) == 0x000410, "Wrong size on UGizmoBaseComponent");
static_assert(offsetof(UGizmoBaseComponent, Color) == 0x0003E8, "Member 'UGizmoBaseComponent::Color' has a wrong offset!");
static_assert(offsetof(UGizmoBaseComponent, HoverSizeMultiplier) == 0x0003F8, "Member 'UGizmoBaseComponent::HoverSizeMultiplier' has a wrong offset!");
static_assert(offsetof(UGizmoBaseComponent, PixelHitDistanceThreshold) == 0x0003FC, "Member 'UGizmoBaseComponent::PixelHitDistanceThreshold' has a wrong offset!");

// Class InteractiveToolsFramework.GizmoArrowComponent
// 0x0020 (0x0430 - 0x0410)
class UGizmoArrowComponent final : public UGizmoBaseComponent
{
public:
	struct FVector                                Direction;                                         // 0x0408(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Gap;                                               // 0x0414(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Length;                                            // 0x0418(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Thickness;                                         // 0x041C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_420[0x10];                                     // 0x0420(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GizmoArrowComponent">();
	}
	static class UGizmoArrowComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGizmoArrowComponent>();
	}
};
static_assert(alignof(UGizmoArrowComponent) == 0x000010, "Wrong alignment on UGizmoArrowComponent");
static_assert(sizeof(UGizmoArrowComponent) == 0x000430, "Wrong size on UGizmoArrowComponent");
static_assert(offsetof(UGizmoArrowComponent, Direction) == 0x000408, "Member 'UGizmoArrowComponent::Direction' has a wrong offset!");
static_assert(offsetof(UGizmoArrowComponent, Gap) == 0x000414, "Member 'UGizmoArrowComponent::Gap' has a wrong offset!");
static_assert(offsetof(UGizmoArrowComponent, Length) == 0x000418, "Member 'UGizmoArrowComponent::Length' has a wrong offset!");
static_assert(offsetof(UGizmoArrowComponent, Thickness) == 0x00041C, "Member 'UGizmoArrowComponent::Thickness' has a wrong offset!");

// Class InteractiveToolsFramework.GizmoCircleComponent
// 0x0020 (0x0430 - 0x0410)
class UGizmoCircleComponent final : public UGizmoBaseComponent
{
public:
	struct FVector                                Normal;                                            // 0x0408(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Radius;                                            // 0x0414(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Thickness;                                         // 0x0418(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NumSides;                                          // 0x041C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bViewAligned;                                      // 0x0420(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOnlyAllowFrontFacingHits;                         // 0x0421(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_422[0xE];                                      // 0x0422(0x000E)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GizmoCircleComponent">();
	}
	static class UGizmoCircleComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGizmoCircleComponent>();
	}
};
static_assert(alignof(UGizmoCircleComponent) == 0x000010, "Wrong alignment on UGizmoCircleComponent");
static_assert(sizeof(UGizmoCircleComponent) == 0x000430, "Wrong size on UGizmoCircleComponent");
static_assert(offsetof(UGizmoCircleComponent, Normal) == 0x000408, "Member 'UGizmoCircleComponent::Normal' has a wrong offset!");
static_assert(offsetof(UGizmoCircleComponent, Radius) == 0x000414, "Member 'UGizmoCircleComponent::Radius' has a wrong offset!");
static_assert(offsetof(UGizmoCircleComponent, Thickness) == 0x000418, "Member 'UGizmoCircleComponent::Thickness' has a wrong offset!");
static_assert(offsetof(UGizmoCircleComponent, NumSides) == 0x00041C, "Member 'UGizmoCircleComponent::NumSides' has a wrong offset!");
static_assert(offsetof(UGizmoCircleComponent, bViewAligned) == 0x000420, "Member 'UGizmoCircleComponent::bViewAligned' has a wrong offset!");
static_assert(offsetof(UGizmoCircleComponent, bOnlyAllowFrontFacingHits) == 0x000421, "Member 'UGizmoCircleComponent::bOnlyAllowFrontFacingHits' has a wrong offset!");

// Class InteractiveToolsFramework.GizmoTransformSource
// 0x0000 (0x0028 - 0x0028)
class IGizmoTransformSource final : public IInterface
{
public:
	void SetTransform(const struct FTransform& NewTransform);

	struct FTransform GetTransform() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GizmoTransformSource">();
	}
	static class IGizmoTransformSource* GetDefaultObj()
	{
		return GetDefaultObjImpl<IGizmoTransformSource>();
	}
};
static_assert(alignof(IGizmoTransformSource) == 0x000008, "Wrong alignment on IGizmoTransformSource");
static_assert(sizeof(IGizmoTransformSource) == 0x000028, "Wrong size on IGizmoTransformSource");

// Class InteractiveToolsFramework.GizmoAxisSource
// 0x0000 (0x0028 - 0x0028)
class IGizmoAxisSource final : public IInterface
{
public:
	struct FVector GetDirection() const;
	struct FVector GetOrigin() const;
	void GetTangentVectors(struct FVector* TangentXOut, struct FVector* TangentYOut) const;
	bool HasTangentVectors() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GizmoAxisSource">();
	}
	static class IGizmoAxisSource* GetDefaultObj()
	{
		return GetDefaultObjImpl<IGizmoAxisSource>();
	}
};
static_assert(alignof(IGizmoAxisSource) == 0x000008, "Wrong alignment on IGizmoAxisSource");
static_assert(sizeof(IGizmoAxisSource) == 0x000028, "Wrong size on IGizmoAxisSource");

// Class InteractiveToolsFramework.GizmoClickTarget
// 0x0000 (0x0028 - 0x0028)
class IGizmoClickTarget final : public IInterface
{
public:
	void UpdateHoverState(bool bHovering) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GizmoClickTarget">();
	}
	static class IGizmoClickTarget* GetDefaultObj()
	{
		return GetDefaultObjImpl<IGizmoClickTarget>();
	}
};
static_assert(alignof(IGizmoClickTarget) == 0x000008, "Wrong alignment on IGizmoClickTarget");
static_assert(sizeof(IGizmoClickTarget) == 0x000028, "Wrong size on IGizmoClickTarget");

// Class InteractiveToolsFramework.GizmoStateTarget
// 0x0000 (0x0028 - 0x0028)
class IGizmoStateTarget final : public IInterface
{
public:
	void BeginUpdate();
	void EndUpdate();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GizmoStateTarget">();
	}
	static class IGizmoStateTarget* GetDefaultObj()
	{
		return GetDefaultObjImpl<IGizmoStateTarget>();
	}
};
static_assert(alignof(IGizmoStateTarget) == 0x000008, "Wrong alignment on IGizmoStateTarget");
static_assert(sizeof(IGizmoStateTarget) == 0x000028, "Wrong size on IGizmoStateTarget");

// Class InteractiveToolsFramework.GizmoFloatParameterSource
// 0x0000 (0x0028 - 0x0028)
class IGizmoFloatParameterSource final : public IInterface
{
public:
	void BeginModify();
	void EndModify();
	void SetParameter(float NewValue);

	float GetParameter() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GizmoFloatParameterSource">();
	}
	static class IGizmoFloatParameterSource* GetDefaultObj()
	{
		return GetDefaultObjImpl<IGizmoFloatParameterSource>();
	}
};
static_assert(alignof(IGizmoFloatParameterSource) == 0x000008, "Wrong alignment on IGizmoFloatParameterSource");
static_assert(sizeof(IGizmoFloatParameterSource) == 0x000028, "Wrong size on IGizmoFloatParameterSource");

// Class InteractiveToolsFramework.GizmoVec2ParameterSource
// 0x0000 (0x0028 - 0x0028)
class IGizmoVec2ParameterSource final : public IInterface
{
public:
	void BeginModify();
	void EndModify();
	void SetParameter(const struct FVector2D& NewValue);

	struct FVector2D GetParameter() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GizmoVec2ParameterSource">();
	}
	static class IGizmoVec2ParameterSource* GetDefaultObj()
	{
		return GetDefaultObjImpl<IGizmoVec2ParameterSource>();
	}
};
static_assert(alignof(IGizmoVec2ParameterSource) == 0x000008, "Wrong alignment on IGizmoVec2ParameterSource");
static_assert(sizeof(IGizmoVec2ParameterSource) == 0x000028, "Wrong size on IGizmoVec2ParameterSource");

// Class InteractiveToolsFramework.GizmoRectangleComponent
// 0x0030 (0x0440 - 0x0410)
class UGizmoRectangleComponent final : public UGizmoBaseComponent
{
public:
	struct FVector                                DirectionX;                                        // 0x0408(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                DirectionY;                                        // 0x0414(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OffsetX;                                           // 0x0420(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OffsetY;                                           // 0x0424(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LengthX;                                           // 0x0428(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LengthY;                                           // 0x042C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Thickness;                                         // 0x0430(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_434[0xC];                                      // 0x0434(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GizmoRectangleComponent">();
	}
	static class UGizmoRectangleComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGizmoRectangleComponent>();
	}
};
static_assert(alignof(UGizmoRectangleComponent) == 0x000010, "Wrong alignment on UGizmoRectangleComponent");
static_assert(sizeof(UGizmoRectangleComponent) == 0x000440, "Wrong size on UGizmoRectangleComponent");
static_assert(offsetof(UGizmoRectangleComponent, DirectionX) == 0x000408, "Member 'UGizmoRectangleComponent::DirectionX' has a wrong offset!");
static_assert(offsetof(UGizmoRectangleComponent, DirectionY) == 0x000414, "Member 'UGizmoRectangleComponent::DirectionY' has a wrong offset!");
static_assert(offsetof(UGizmoRectangleComponent, OffsetX) == 0x000420, "Member 'UGizmoRectangleComponent::OffsetX' has a wrong offset!");
static_assert(offsetof(UGizmoRectangleComponent, OffsetY) == 0x000424, "Member 'UGizmoRectangleComponent::OffsetY' has a wrong offset!");
static_assert(offsetof(UGizmoRectangleComponent, LengthX) == 0x000428, "Member 'UGizmoRectangleComponent::LengthX' has a wrong offset!");
static_assert(offsetof(UGizmoRectangleComponent, LengthY) == 0x00042C, "Member 'UGizmoRectangleComponent::LengthY' has a wrong offset!");
static_assert(offsetof(UGizmoRectangleComponent, Thickness) == 0x000430, "Member 'UGizmoRectangleComponent::Thickness' has a wrong offset!");

// Class InteractiveToolsFramework.GizmoLambdaHitTarget
// 0x0088 (0x00B0 - 0x0028)
class UGizmoLambdaHitTarget final : public UObject
{
public:
	uint8                                         Pad_28[0x88];                                      // 0x0028(0x0088)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GizmoLambdaHitTarget">();
	}
	static class UGizmoLambdaHitTarget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGizmoLambdaHitTarget>();
	}
};
static_assert(alignof(UGizmoLambdaHitTarget) == 0x000008, "Wrong alignment on UGizmoLambdaHitTarget");
static_assert(sizeof(UGizmoLambdaHitTarget) == 0x0000B0, "Wrong size on UGizmoLambdaHitTarget");

// Class InteractiveToolsFramework.GizmoComponentHitTarget
// 0x0058 (0x0080 - 0x0028)
class alignas(0x10) UGizmoComponentHitTarget final : public UObject
{
public:
	uint8                                         Pad_28[0x8];                                       // 0x0028(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UPrimitiveComponent*                    Component;                                         // 0x0030(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_38[0x48];                                      // 0x0038(0x0048)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GizmoComponentHitTarget">();
	}
	static class UGizmoComponentHitTarget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGizmoComponentHitTarget>();
	}
};
static_assert(alignof(UGizmoComponentHitTarget) == 0x000010, "Wrong alignment on UGizmoComponentHitTarget");
static_assert(sizeof(UGizmoComponentHitTarget) == 0x000080, "Wrong size on UGizmoComponentHitTarget");
static_assert(offsetof(UGizmoComponentHitTarget, Component) == 0x000030, "Member 'UGizmoComponentHitTarget::Component' has a wrong offset!");

// Class InteractiveToolsFramework.InputBehaviorSet
// 0x0010 (0x0038 - 0x0028)
class UInputBehaviorSet final : public UObject
{
public:
	TArray<struct FBehaviorInfo>                  Behaviors;                                         // 0x0028(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InputBehaviorSet">();
	}
	static class UInputBehaviorSet* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInputBehaviorSet>();
	}
};
static_assert(alignof(UInputBehaviorSet) == 0x000008, "Wrong alignment on UInputBehaviorSet");
static_assert(sizeof(UInputBehaviorSet) == 0x000038, "Wrong size on UInputBehaviorSet");
static_assert(offsetof(UInputBehaviorSet, Behaviors) == 0x000028, "Member 'UInputBehaviorSet::Behaviors' has a wrong offset!");

// Class InteractiveToolsFramework.InputBehaviorSource
// 0x0000 (0x0028 - 0x0028)
class IInputBehaviorSource final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InputBehaviorSource">();
	}
	static class IInputBehaviorSource* GetDefaultObj()
	{
		return GetDefaultObjImpl<IInputBehaviorSource>();
	}
};
static_assert(alignof(IInputBehaviorSource) == 0x000008, "Wrong alignment on IInputBehaviorSource");
static_assert(sizeof(IInputBehaviorSource) == 0x000028, "Wrong size on IInputBehaviorSource");

// Class InteractiveToolsFramework.InputRouter
// 0x0088 (0x00B0 - 0x0028)
class UInputRouter final : public UObject
{
public:
	bool                                          bAutoInvalidateOnHover;                            // 0x0028(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAutoInvalidateOnCapture;                          // 0x0029(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2A[0xE];                                       // 0x002A(0x000E)(Fixing Size After Last Property [ Dumper-7 ])
	class UInputBehaviorSet*                      ActiveInputBehaviors;                              // 0x0038(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_40[0x70];                                      // 0x0040(0x0070)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InputRouter">();
	}
	static class UInputRouter* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInputRouter>();
	}
};
static_assert(alignof(UInputRouter) == 0x000008, "Wrong alignment on UInputRouter");
static_assert(sizeof(UInputRouter) == 0x0000B0, "Wrong size on UInputRouter");
static_assert(offsetof(UInputRouter, bAutoInvalidateOnHover) == 0x000028, "Member 'UInputRouter::bAutoInvalidateOnHover' has a wrong offset!");
static_assert(offsetof(UInputRouter, bAutoInvalidateOnCapture) == 0x000029, "Member 'UInputRouter::bAutoInvalidateOnCapture' has a wrong offset!");
static_assert(offsetof(UInputRouter, ActiveInputBehaviors) == 0x000038, "Member 'UInputRouter::ActiveInputBehaviors' has a wrong offset!");

// Class InteractiveToolsFramework.InteractiveGizmoManager
// 0x0090 (0x00B8 - 0x0028)
class UInteractiveGizmoManager final : public UObject
{
public:
	uint8                                         Pad_28[0x8];                                       // 0x0028(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FActiveGizmo>                   ActiveGizmos;                                      // 0x0030(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_40[0x18];                                      // 0x0040(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class FString, class UInteractiveGizmoBuilder*> GizmoBuilders;                                     // 0x0058(0x0050)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_A8[0x10];                                      // 0x00A8(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InteractiveGizmoManager">();
	}
	static class UInteractiveGizmoManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInteractiveGizmoManager>();
	}
};
static_assert(alignof(UInteractiveGizmoManager) == 0x000008, "Wrong alignment on UInteractiveGizmoManager");
static_assert(sizeof(UInteractiveGizmoManager) == 0x0000B8, "Wrong size on UInteractiveGizmoManager");
static_assert(offsetof(UInteractiveGizmoManager, ActiveGizmos) == 0x000030, "Member 'UInteractiveGizmoManager::ActiveGizmos' has a wrong offset!");
static_assert(offsetof(UInteractiveGizmoManager, GizmoBuilders) == 0x000058, "Member 'UInteractiveGizmoManager::GizmoBuilders' has a wrong offset!");

// Class InteractiveToolsFramework.InteractiveToolPropertySet
// 0x0020 (0x0048 - 0x0028)
class UInteractiveToolPropertySet final : public UObject
{
public:
	uint8                                         Pad_28[0x18];                                      // 0x0028(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class UObject*                                CachedProperties;                                  // 0x0040(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InteractiveToolPropertySet">();
	}
	static class UInteractiveToolPropertySet* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInteractiveToolPropertySet>();
	}
};
static_assert(alignof(UInteractiveToolPropertySet) == 0x000008, "Wrong alignment on UInteractiveToolPropertySet");
static_assert(sizeof(UInteractiveToolPropertySet) == 0x000048, "Wrong size on UInteractiveToolPropertySet");
static_assert(offsetof(UInteractiveToolPropertySet, CachedProperties) == 0x000040, "Member 'UInteractiveToolPropertySet::CachedProperties' has a wrong offset!");

// Class InteractiveToolsFramework.ToolContextTransactionProvider
// 0x0000 (0x0028 - 0x0028)
class IToolContextTransactionProvider final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ToolContextTransactionProvider">();
	}
	static class IToolContextTransactionProvider* GetDefaultObj()
	{
		return GetDefaultObjImpl<IToolContextTransactionProvider>();
	}
};
static_assert(alignof(IToolContextTransactionProvider) == 0x000008, "Wrong alignment on IToolContextTransactionProvider");
static_assert(sizeof(IToolContextTransactionProvider) == 0x000028, "Wrong size on IToolContextTransactionProvider");

// Class InteractiveToolsFramework.InteractiveToolManager
// 0x00C0 (0x00E8 - 0x0028)
class UInteractiveToolManager final : public UObject
{
public:
	uint8                                         Pad_28[0x8];                                       // 0x0028(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UInteractiveTool*                       ActiveLeftTool;                                    // 0x0030(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UInteractiveTool*                       ActiveRightTool;                                   // 0x0038(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_40[0x48];                                      // 0x0040(0x0048)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class FString, class UInteractiveToolBuilder*> ToolBuilders;                                      // 0x0088(0x0050)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_D8[0x10];                                      // 0x00D8(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InteractiveToolManager">();
	}
	static class UInteractiveToolManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInteractiveToolManager>();
	}
};
static_assert(alignof(UInteractiveToolManager) == 0x000008, "Wrong alignment on UInteractiveToolManager");
static_assert(sizeof(UInteractiveToolManager) == 0x0000E8, "Wrong size on UInteractiveToolManager");
static_assert(offsetof(UInteractiveToolManager, ActiveLeftTool) == 0x000030, "Member 'UInteractiveToolManager::ActiveLeftTool' has a wrong offset!");
static_assert(offsetof(UInteractiveToolManager, ActiveRightTool) == 0x000038, "Member 'UInteractiveToolManager::ActiveRightTool' has a wrong offset!");
static_assert(offsetof(UInteractiveToolManager, ToolBuilders) == 0x000088, "Member 'UInteractiveToolManager::ToolBuilders' has a wrong offset!");

// Class InteractiveToolsFramework.ToolFrameworkComponent
// 0x0000 (0x0028 - 0x0028)
class IToolFrameworkComponent final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ToolFrameworkComponent">();
	}
	static class IToolFrameworkComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<IToolFrameworkComponent>();
	}
};
static_assert(alignof(IToolFrameworkComponent) == 0x000008, "Wrong alignment on IToolFrameworkComponent");
static_assert(sizeof(IToolFrameworkComponent) == 0x000028, "Wrong size on IToolFrameworkComponent");

// Class InteractiveToolsFramework.InteractiveToolsContext
// 0x0018 (0x0040 - 0x0028)
class UInteractiveToolsContext final : public UObject
{
public:
	class UInputRouter*                           InputRouter;                                       // 0x0028(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UInteractiveToolManager*                ToolManager;                                       // 0x0030(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UInteractiveGizmoManager*               GizmoManager;                                      // 0x0038(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InteractiveToolsContext">();
	}
	static class UInteractiveToolsContext* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInteractiveToolsContext>();
	}
};
static_assert(alignof(UInteractiveToolsContext) == 0x000008, "Wrong alignment on UInteractiveToolsContext");
static_assert(sizeof(UInteractiveToolsContext) == 0x000040, "Wrong size on UInteractiveToolsContext");
static_assert(offsetof(UInteractiveToolsContext, InputRouter) == 0x000028, "Member 'UInteractiveToolsContext::InputRouter' has a wrong offset!");
static_assert(offsetof(UInteractiveToolsContext, ToolManager) == 0x000030, "Member 'UInteractiveToolsContext::ToolManager' has a wrong offset!");
static_assert(offsetof(UInteractiveToolsContext, GizmoManager) == 0x000038, "Member 'UInteractiveToolsContext::GizmoManager' has a wrong offset!");

// Class InteractiveToolsFramework.KeyAsModifierInputBehavior
// 0x00E0 (0x0110 - 0x0030)
class UKeyAsModifierInputBehavior final : public UInputBehavior
{
public:
	uint8                                         Pad_30[0xE0];                                      // 0x0030(0x00E0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KeyAsModifierInputBehavior">();
	}
	static class UKeyAsModifierInputBehavior* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKeyAsModifierInputBehavior>();
	}
};
static_assert(alignof(UKeyAsModifierInputBehavior) == 0x000008, "Wrong alignment on UKeyAsModifierInputBehavior");
static_assert(sizeof(UKeyAsModifierInputBehavior) == 0x000110, "Wrong size on UKeyAsModifierInputBehavior");

// Class InteractiveToolsFramework.MeshSurfacePointToolBuilder
// 0x0000 (0x0028 - 0x0028)
class UMeshSurfacePointToolBuilder final : public UInteractiveToolBuilder
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MeshSurfacePointToolBuilder">();
	}
	static class UMeshSurfacePointToolBuilder* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMeshSurfacePointToolBuilder>();
	}
};
static_assert(alignof(UMeshSurfacePointToolBuilder) == 0x000008, "Wrong alignment on UMeshSurfacePointToolBuilder");
static_assert(sizeof(UMeshSurfacePointToolBuilder) == 0x000028, "Wrong size on UMeshSurfacePointToolBuilder");

// Class InteractiveToolsFramework.SingleSelectionTool
// 0x0008 (0x0058 - 0x0050)
class USingleSelectionTool : public UInteractiveTool
{
public:
	uint8                                         Pad_50[0x8];                                       // 0x0050(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SingleSelectionTool">();
	}
	static class USingleSelectionTool* GetDefaultObj()
	{
		return GetDefaultObjImpl<USingleSelectionTool>();
	}
};
static_assert(alignof(USingleSelectionTool) == 0x000008, "Wrong alignment on USingleSelectionTool");
static_assert(sizeof(USingleSelectionTool) == 0x000058, "Wrong size on USingleSelectionTool");

// Class InteractiveToolsFramework.MeshSurfacePointTool
// 0x0010 (0x0068 - 0x0058)
class UMeshSurfacePointTool final : public USingleSelectionTool
{
public:
	uint8                                         Pad_58[0x10];                                      // 0x0058(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MeshSurfacePointTool">();
	}
	static class UMeshSurfacePointTool* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMeshSurfacePointTool>();
	}
};
static_assert(alignof(UMeshSurfacePointTool) == 0x000008, "Wrong alignment on UMeshSurfacePointTool");
static_assert(sizeof(UMeshSurfacePointTool) == 0x000068, "Wrong size on UMeshSurfacePointTool");

// Class InteractiveToolsFramework.MeshSurfacePointToolMouseBehavior
// 0x0028 (0x0060 - 0x0038)
class UMeshSurfacePointToolMouseBehavior final : public UAnyButtonInputBehavior
{
public:
	uint8                                         Pad_38[0x28];                                      // 0x0038(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MeshSurfacePointToolMouseBehavior">();
	}
	static class UMeshSurfacePointToolMouseBehavior* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMeshSurfacePointToolMouseBehavior>();
	}
};
static_assert(alignof(UMeshSurfacePointToolMouseBehavior) == 0x000008, "Wrong alignment on UMeshSurfacePointToolMouseBehavior");
static_assert(sizeof(UMeshSurfacePointToolMouseBehavior) == 0x000060, "Wrong size on UMeshSurfacePointToolMouseBehavior");

// Class InteractiveToolsFramework.MouseHoverBehavior
// 0x0068 (0x0098 - 0x0030)
class UMouseHoverBehavior final : public UInputBehavior
{
public:
	uint8                                         Pad_30[0x68];                                      // 0x0030(0x0068)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MouseHoverBehavior">();
	}
	static class UMouseHoverBehavior* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMouseHoverBehavior>();
	}
};
static_assert(alignof(UMouseHoverBehavior) == 0x000008, "Wrong alignment on UMouseHoverBehavior");
static_assert(sizeof(UMouseHoverBehavior) == 0x000098, "Wrong size on UMouseHoverBehavior");

// Class InteractiveToolsFramework.MultiClickSequenceInputBehavior
// 0x00B8 (0x00F0 - 0x0038)
class UMultiClickSequenceInputBehavior final : public UAnyButtonInputBehavior
{
public:
	uint8                                         Pad_38[0xB8];                                      // 0x0038(0x00B8)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MultiClickSequenceInputBehavior">();
	}
	static class UMultiClickSequenceInputBehavior* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMultiClickSequenceInputBehavior>();
	}
};
static_assert(alignof(UMultiClickSequenceInputBehavior) == 0x000008, "Wrong alignment on UMultiClickSequenceInputBehavior");
static_assert(sizeof(UMultiClickSequenceInputBehavior) == 0x0000F0, "Wrong size on UMultiClickSequenceInputBehavior");

// Class InteractiveToolsFramework.MultiSelectionTool
// 0x0010 (0x0060 - 0x0050)
class UMultiSelectionTool final : public UInteractiveTool
{
public:
	uint8                                         Pad_50[0x10];                                      // 0x0050(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MultiSelectionTool">();
	}
	static class UMultiSelectionTool* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMultiSelectionTool>();
	}
};
static_assert(alignof(UMultiSelectionTool) == 0x000008, "Wrong alignment on UMultiSelectionTool");
static_assert(sizeof(UMultiSelectionTool) == 0x000060, "Wrong size on UMultiSelectionTool");

// Class InteractiveToolsFramework.GizmoBaseFloatParameterSource
// 0x0020 (0x0048 - 0x0028)
class UGizmoBaseFloatParameterSource : public UObject
{
public:
	uint8                                         Pad_28[0x20];                                      // 0x0028(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GizmoBaseFloatParameterSource">();
	}
	static class UGizmoBaseFloatParameterSource* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGizmoBaseFloatParameterSource>();
	}
};
static_assert(alignof(UGizmoBaseFloatParameterSource) == 0x000008, "Wrong alignment on UGizmoBaseFloatParameterSource");
static_assert(sizeof(UGizmoBaseFloatParameterSource) == 0x000048, "Wrong size on UGizmoBaseFloatParameterSource");

// Class InteractiveToolsFramework.GizmoLocalFloatParameterSource
// 0x0010 (0x0058 - 0x0048)
class UGizmoLocalFloatParameterSource final : public UGizmoBaseFloatParameterSource
{
public:
	float                                         Value;                                             // 0x0048(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGizmoFloatParameterChange             LastChange;                                        // 0x004C(0x0008)(NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_54[0x4];                                       // 0x0054(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GizmoLocalFloatParameterSource">();
	}
	static class UGizmoLocalFloatParameterSource* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGizmoLocalFloatParameterSource>();
	}
};
static_assert(alignof(UGizmoLocalFloatParameterSource) == 0x000008, "Wrong alignment on UGizmoLocalFloatParameterSource");
static_assert(sizeof(UGizmoLocalFloatParameterSource) == 0x000058, "Wrong size on UGizmoLocalFloatParameterSource");
static_assert(offsetof(UGizmoLocalFloatParameterSource, Value) == 0x000048, "Member 'UGizmoLocalFloatParameterSource::Value' has a wrong offset!");
static_assert(offsetof(UGizmoLocalFloatParameterSource, LastChange) == 0x00004C, "Member 'UGizmoLocalFloatParameterSource::LastChange' has a wrong offset!");

// Class InteractiveToolsFramework.GizmoBaseVec2ParameterSource
// 0x0020 (0x0048 - 0x0028)
class UGizmoBaseVec2ParameterSource : public UObject
{
public:
	uint8                                         Pad_28[0x20];                                      // 0x0028(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GizmoBaseVec2ParameterSource">();
	}
	static class UGizmoBaseVec2ParameterSource* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGizmoBaseVec2ParameterSource>();
	}
};
static_assert(alignof(UGizmoBaseVec2ParameterSource) == 0x000008, "Wrong alignment on UGizmoBaseVec2ParameterSource");
static_assert(sizeof(UGizmoBaseVec2ParameterSource) == 0x000048, "Wrong size on UGizmoBaseVec2ParameterSource");

// Class InteractiveToolsFramework.GizmoLocalVec2ParameterSource
// 0x0018 (0x0060 - 0x0048)
class UGizmoLocalVec2ParameterSource final : public UGizmoBaseVec2ParameterSource
{
public:
	struct FVector2D                              Value;                                             // 0x0048(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGizmoVec2ParameterChange              LastChange;                                        // 0x0050(0x0010)(NoDestructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GizmoLocalVec2ParameterSource">();
	}
	static class UGizmoLocalVec2ParameterSource* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGizmoLocalVec2ParameterSource>();
	}
};
static_assert(alignof(UGizmoLocalVec2ParameterSource) == 0x000008, "Wrong alignment on UGizmoLocalVec2ParameterSource");
static_assert(sizeof(UGizmoLocalVec2ParameterSource) == 0x000060, "Wrong size on UGizmoLocalVec2ParameterSource");
static_assert(offsetof(UGizmoLocalVec2ParameterSource, Value) == 0x000048, "Member 'UGizmoLocalVec2ParameterSource::Value' has a wrong offset!");
static_assert(offsetof(UGizmoLocalVec2ParameterSource, LastChange) == 0x000050, "Member 'UGizmoLocalVec2ParameterSource::LastChange' has a wrong offset!");

// Class InteractiveToolsFramework.GizmoAxisTranslationParameterSource
// 0x0078 (0x00C0 - 0x0048)
class UGizmoAxisTranslationParameterSource final : public UGizmoBaseFloatParameterSource
{
public:
	TScriptInterface<class IGizmoAxisSource>      AxisSource;                                        // 0x0048(0x0010)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, NativeAccessSpecifierPublic)
	TScriptInterface<class IGizmoTransformSource> TransformSource;                                   // 0x0058(0x0010)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, NativeAccessSpecifierPublic)
	float                                         Parameter;                                         // 0x0068(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGizmoFloatParameterChange             LastChange;                                        // 0x006C(0x0008)(NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                CurTranslationAxis;                                // 0x0074(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                CurTranslationOrigin;                              // 0x0080(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8C[0x4];                                       // 0x008C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             InitialTransform;                                  // 0x0090(0x0030)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GizmoAxisTranslationParameterSource">();
	}
	static class UGizmoAxisTranslationParameterSource* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGizmoAxisTranslationParameterSource>();
	}
};
static_assert(alignof(UGizmoAxisTranslationParameterSource) == 0x000010, "Wrong alignment on UGizmoAxisTranslationParameterSource");
static_assert(sizeof(UGizmoAxisTranslationParameterSource) == 0x0000C0, "Wrong size on UGizmoAxisTranslationParameterSource");
static_assert(offsetof(UGizmoAxisTranslationParameterSource, AxisSource) == 0x000048, "Member 'UGizmoAxisTranslationParameterSource::AxisSource' has a wrong offset!");
static_assert(offsetof(UGizmoAxisTranslationParameterSource, TransformSource) == 0x000058, "Member 'UGizmoAxisTranslationParameterSource::TransformSource' has a wrong offset!");
static_assert(offsetof(UGizmoAxisTranslationParameterSource, Parameter) == 0x000068, "Member 'UGizmoAxisTranslationParameterSource::Parameter' has a wrong offset!");
static_assert(offsetof(UGizmoAxisTranslationParameterSource, LastChange) == 0x00006C, "Member 'UGizmoAxisTranslationParameterSource::LastChange' has a wrong offset!");
static_assert(offsetof(UGizmoAxisTranslationParameterSource, CurTranslationAxis) == 0x000074, "Member 'UGizmoAxisTranslationParameterSource::CurTranslationAxis' has a wrong offset!");
static_assert(offsetof(UGizmoAxisTranslationParameterSource, CurTranslationOrigin) == 0x000080, "Member 'UGizmoAxisTranslationParameterSource::CurTranslationOrigin' has a wrong offset!");
static_assert(offsetof(UGizmoAxisTranslationParameterSource, InitialTransform) == 0x000090, "Member 'UGizmoAxisTranslationParameterSource::InitialTransform' has a wrong offset!");

// Class InteractiveToolsFramework.GizmoPlaneTranslationParameterSource
// 0x0098 (0x00E0 - 0x0048)
class UGizmoPlaneTranslationParameterSource final : public UGizmoBaseVec2ParameterSource
{
public:
	TScriptInterface<class IGizmoAxisSource>      AxisSource;                                        // 0x0048(0x0010)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, NativeAccessSpecifierPublic)
	TScriptInterface<class IGizmoTransformSource> TransformSource;                                   // 0x0058(0x0010)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, NativeAccessSpecifierPublic)
	struct FVector2D                              Parameter;                                         // 0x0068(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGizmoVec2ParameterChange              LastChange;                                        // 0x0070(0x0010)(NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                CurTranslationOrigin;                              // 0x0080(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                CurTranslationNormal;                              // 0x008C(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                CurTranslationAxisX;                               // 0x0098(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                CurTranslationAxisY;                               // 0x00A4(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTransform                             InitialTransform;                                  // 0x00B0(0x0030)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GizmoPlaneTranslationParameterSource">();
	}
	static class UGizmoPlaneTranslationParameterSource* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGizmoPlaneTranslationParameterSource>();
	}
};
static_assert(alignof(UGizmoPlaneTranslationParameterSource) == 0x000010, "Wrong alignment on UGizmoPlaneTranslationParameterSource");
static_assert(sizeof(UGizmoPlaneTranslationParameterSource) == 0x0000E0, "Wrong size on UGizmoPlaneTranslationParameterSource");
static_assert(offsetof(UGizmoPlaneTranslationParameterSource, AxisSource) == 0x000048, "Member 'UGizmoPlaneTranslationParameterSource::AxisSource' has a wrong offset!");
static_assert(offsetof(UGizmoPlaneTranslationParameterSource, TransformSource) == 0x000058, "Member 'UGizmoPlaneTranslationParameterSource::TransformSource' has a wrong offset!");
static_assert(offsetof(UGizmoPlaneTranslationParameterSource, Parameter) == 0x000068, "Member 'UGizmoPlaneTranslationParameterSource::Parameter' has a wrong offset!");
static_assert(offsetof(UGizmoPlaneTranslationParameterSource, LastChange) == 0x000070, "Member 'UGizmoPlaneTranslationParameterSource::LastChange' has a wrong offset!");
static_assert(offsetof(UGizmoPlaneTranslationParameterSource, CurTranslationOrigin) == 0x000080, "Member 'UGizmoPlaneTranslationParameterSource::CurTranslationOrigin' has a wrong offset!");
static_assert(offsetof(UGizmoPlaneTranslationParameterSource, CurTranslationNormal) == 0x00008C, "Member 'UGizmoPlaneTranslationParameterSource::CurTranslationNormal' has a wrong offset!");
static_assert(offsetof(UGizmoPlaneTranslationParameterSource, CurTranslationAxisX) == 0x000098, "Member 'UGizmoPlaneTranslationParameterSource::CurTranslationAxisX' has a wrong offset!");
static_assert(offsetof(UGizmoPlaneTranslationParameterSource, CurTranslationAxisY) == 0x0000A4, "Member 'UGizmoPlaneTranslationParameterSource::CurTranslationAxisY' has a wrong offset!");
static_assert(offsetof(UGizmoPlaneTranslationParameterSource, InitialTransform) == 0x0000B0, "Member 'UGizmoPlaneTranslationParameterSource::InitialTransform' has a wrong offset!");

// Class InteractiveToolsFramework.GizmoAxisRotationParameterSource
// 0x0078 (0x00C0 - 0x0048)
class UGizmoAxisRotationParameterSource final : public UGizmoBaseFloatParameterSource
{
public:
	TScriptInterface<class IGizmoAxisSource>      AxisSource;                                        // 0x0048(0x0010)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, NativeAccessSpecifierPublic)
	TScriptInterface<class IGizmoTransformSource> TransformSource;                                   // 0x0058(0x0010)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, NativeAccessSpecifierPublic)
	float                                         Angle;                                             // 0x0068(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGizmoFloatParameterChange             LastChange;                                        // 0x006C(0x0008)(NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                CurRotationAxis;                                   // 0x0074(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                CurRotationOrigin;                                 // 0x0080(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8C[0x4];                                       // 0x008C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             InitialTransform;                                  // 0x0090(0x0030)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GizmoAxisRotationParameterSource">();
	}
	static class UGizmoAxisRotationParameterSource* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGizmoAxisRotationParameterSource>();
	}
};
static_assert(alignof(UGizmoAxisRotationParameterSource) == 0x000010, "Wrong alignment on UGizmoAxisRotationParameterSource");
static_assert(sizeof(UGizmoAxisRotationParameterSource) == 0x0000C0, "Wrong size on UGizmoAxisRotationParameterSource");
static_assert(offsetof(UGizmoAxisRotationParameterSource, AxisSource) == 0x000048, "Member 'UGizmoAxisRotationParameterSource::AxisSource' has a wrong offset!");
static_assert(offsetof(UGizmoAxisRotationParameterSource, TransformSource) == 0x000058, "Member 'UGizmoAxisRotationParameterSource::TransformSource' has a wrong offset!");
static_assert(offsetof(UGizmoAxisRotationParameterSource, Angle) == 0x000068, "Member 'UGizmoAxisRotationParameterSource::Angle' has a wrong offset!");
static_assert(offsetof(UGizmoAxisRotationParameterSource, LastChange) == 0x00006C, "Member 'UGizmoAxisRotationParameterSource::LastChange' has a wrong offset!");
static_assert(offsetof(UGizmoAxisRotationParameterSource, CurRotationAxis) == 0x000074, "Member 'UGizmoAxisRotationParameterSource::CurRotationAxis' has a wrong offset!");
static_assert(offsetof(UGizmoAxisRotationParameterSource, CurRotationOrigin) == 0x000080, "Member 'UGizmoAxisRotationParameterSource::CurRotationOrigin' has a wrong offset!");
static_assert(offsetof(UGizmoAxisRotationParameterSource, InitialTransform) == 0x000090, "Member 'UGizmoAxisRotationParameterSource::InitialTransform' has a wrong offset!");

// Class InteractiveToolsFramework.PlanePositionGizmoBuilder
// 0x0000 (0x0028 - 0x0028)
class UPlanePositionGizmoBuilder final : public UInteractiveGizmoBuilder
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlanePositionGizmoBuilder">();
	}
	static class UPlanePositionGizmoBuilder* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlanePositionGizmoBuilder>();
	}
};
static_assert(alignof(UPlanePositionGizmoBuilder) == 0x000008, "Wrong alignment on UPlanePositionGizmoBuilder");
static_assert(sizeof(UPlanePositionGizmoBuilder) == 0x000028, "Wrong size on UPlanePositionGizmoBuilder");

// Class InteractiveToolsFramework.PlanePositionGizmo
// 0x00C0 (0x00F8 - 0x0038)
class UPlanePositionGizmo final : public UInteractiveGizmo
{
public:
	uint8                                         Pad_38[0x10];                                      // 0x0038(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TScriptInterface<class IGizmoAxisSource>      AxisSource;                                        // 0x0048(0x0010)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, NativeAccessSpecifierPublic)
	TScriptInterface<class IGizmoVec2ParameterSource> ParameterSource;                                   // 0x0058(0x0010)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, NativeAccessSpecifierPublic)
	TScriptInterface<class IGizmoClickTarget>     HitTarget;                                         // 0x0068(0x0010)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, NativeAccessSpecifierPublic)
	TScriptInterface<class IGizmoStateTarget>     StateTarget;                                       // 0x0078(0x0010)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, NativeAccessSpecifierPublic)
	bool                                          bInInteraction;                                    // 0x0088(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_89[0x3];                                       // 0x0089(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                InteractionOrigin;                                 // 0x008C(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                InteractionNormal;                                 // 0x0098(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                InteractionAxisX;                                  // 0x00A4(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                InteractionAxisY;                                  // 0x00B0(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                InteractionStartPoint;                             // 0x00BC(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                InteractionCurPoint;                               // 0x00C8(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              InteractionStartParameter;                         // 0x00D4(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              InteractionCurParameter;                           // 0x00DC(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E4[0x14];                                      // 0x00E4(0x0014)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlanePositionGizmo">();
	}
	static class UPlanePositionGizmo* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlanePositionGizmo>();
	}
};
static_assert(alignof(UPlanePositionGizmo) == 0x000008, "Wrong alignment on UPlanePositionGizmo");
static_assert(sizeof(UPlanePositionGizmo) == 0x0000F8, "Wrong size on UPlanePositionGizmo");
static_assert(offsetof(UPlanePositionGizmo, AxisSource) == 0x000048, "Member 'UPlanePositionGizmo::AxisSource' has a wrong offset!");
static_assert(offsetof(UPlanePositionGizmo, ParameterSource) == 0x000058, "Member 'UPlanePositionGizmo::ParameterSource' has a wrong offset!");
static_assert(offsetof(UPlanePositionGizmo, HitTarget) == 0x000068, "Member 'UPlanePositionGizmo::HitTarget' has a wrong offset!");
static_assert(offsetof(UPlanePositionGizmo, StateTarget) == 0x000078, "Member 'UPlanePositionGizmo::StateTarget' has a wrong offset!");
static_assert(offsetof(UPlanePositionGizmo, bInInteraction) == 0x000088, "Member 'UPlanePositionGizmo::bInInteraction' has a wrong offset!");
static_assert(offsetof(UPlanePositionGizmo, InteractionOrigin) == 0x00008C, "Member 'UPlanePositionGizmo::InteractionOrigin' has a wrong offset!");
static_assert(offsetof(UPlanePositionGizmo, InteractionNormal) == 0x000098, "Member 'UPlanePositionGizmo::InteractionNormal' has a wrong offset!");
static_assert(offsetof(UPlanePositionGizmo, InteractionAxisX) == 0x0000A4, "Member 'UPlanePositionGizmo::InteractionAxisX' has a wrong offset!");
static_assert(offsetof(UPlanePositionGizmo, InteractionAxisY) == 0x0000B0, "Member 'UPlanePositionGizmo::InteractionAxisY' has a wrong offset!");
static_assert(offsetof(UPlanePositionGizmo, InteractionStartPoint) == 0x0000BC, "Member 'UPlanePositionGizmo::InteractionStartPoint' has a wrong offset!");
static_assert(offsetof(UPlanePositionGizmo, InteractionCurPoint) == 0x0000C8, "Member 'UPlanePositionGizmo::InteractionCurPoint' has a wrong offset!");
static_assert(offsetof(UPlanePositionGizmo, InteractionStartParameter) == 0x0000D4, "Member 'UPlanePositionGizmo::InteractionStartParameter' has a wrong offset!");
static_assert(offsetof(UPlanePositionGizmo, InteractionCurParameter) == 0x0000DC, "Member 'UPlanePositionGizmo::InteractionCurParameter' has a wrong offset!");

// Class InteractiveToolsFramework.SelectionSet
// 0x0018 (0x0040 - 0x0028)
class USelectionSet : public UObject
{
public:
	uint8                                         Pad_28[0x18];                                      // 0x0028(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SelectionSet">();
	}
	static class USelectionSet* GetDefaultObj()
	{
		return GetDefaultObjImpl<USelectionSet>();
	}
};
static_assert(alignof(USelectionSet) == 0x000008, "Wrong alignment on USelectionSet");
static_assert(sizeof(USelectionSet) == 0x000040, "Wrong size on USelectionSet");

// Class InteractiveToolsFramework.MeshSelectionSet
// 0x0040 (0x0080 - 0x0040)
class UMeshSelectionSet final : public USelectionSet
{
public:
	TArray<int32>                                 Vertices;                                          // 0x0040(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<int32>                                 Edges;                                             // 0x0050(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<int32>                                 Faces;                                             // 0x0060(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<int32>                                 Groups;                                            // 0x0070(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MeshSelectionSet">();
	}
	static class UMeshSelectionSet* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMeshSelectionSet>();
	}
};
static_assert(alignof(UMeshSelectionSet) == 0x000008, "Wrong alignment on UMeshSelectionSet");
static_assert(sizeof(UMeshSelectionSet) == 0x000080, "Wrong size on UMeshSelectionSet");
static_assert(offsetof(UMeshSelectionSet, Vertices) == 0x000040, "Member 'UMeshSelectionSet::Vertices' has a wrong offset!");
static_assert(offsetof(UMeshSelectionSet, Edges) == 0x000050, "Member 'UMeshSelectionSet::Edges' has a wrong offset!");
static_assert(offsetof(UMeshSelectionSet, Faces) == 0x000060, "Member 'UMeshSelectionSet::Faces' has a wrong offset!");
static_assert(offsetof(UMeshSelectionSet, Groups) == 0x000070, "Member 'UMeshSelectionSet::Groups' has a wrong offset!");

// Class InteractiveToolsFramework.SingleClickInputBehavior
// 0x0058 (0x0090 - 0x0038)
class USingleClickInputBehavior final : public UAnyButtonInputBehavior
{
public:
	uint8                                         Pad_38[0x48];                                      // 0x0038(0x0048)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          HitTestOnRelease;                                  // 0x0080(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_81[0xF];                                       // 0x0081(0x000F)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SingleClickInputBehavior">();
	}
	static class USingleClickInputBehavior* GetDefaultObj()
	{
		return GetDefaultObjImpl<USingleClickInputBehavior>();
	}
};
static_assert(alignof(USingleClickInputBehavior) == 0x000008, "Wrong alignment on USingleClickInputBehavior");
static_assert(sizeof(USingleClickInputBehavior) == 0x000090, "Wrong size on USingleClickInputBehavior");
static_assert(offsetof(USingleClickInputBehavior, HitTestOnRelease) == 0x000080, "Member 'USingleClickInputBehavior::HitTestOnRelease' has a wrong offset!");

// Class InteractiveToolsFramework.SingleClickToolBuilder
// 0x0000 (0x0028 - 0x0028)
class USingleClickToolBuilder final : public UInteractiveToolBuilder
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SingleClickToolBuilder">();
	}
	static class USingleClickToolBuilder* GetDefaultObj()
	{
		return GetDefaultObjImpl<USingleClickToolBuilder>();
	}
};
static_assert(alignof(USingleClickToolBuilder) == 0x000008, "Wrong alignment on USingleClickToolBuilder");
static_assert(sizeof(USingleClickToolBuilder) == 0x000028, "Wrong size on USingleClickToolBuilder");

// Class InteractiveToolsFramework.SingleClickTool
// 0x0008 (0x0058 - 0x0050)
class USingleClickTool final : public UInteractiveTool
{
public:
	uint8                                         Pad_50[0x8];                                       // 0x0050(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SingleClickTool">();
	}
	static class USingleClickTool* GetDefaultObj()
	{
		return GetDefaultObjImpl<USingleClickTool>();
	}
};
static_assert(alignof(USingleClickTool) == 0x000008, "Wrong alignment on USingleClickTool");
static_assert(sizeof(USingleClickTool) == 0x000058, "Wrong size on USingleClickTool");

// Class InteractiveToolsFramework.GizmoNilStateTarget
// 0x0008 (0x0030 - 0x0028)
class UGizmoNilStateTarget final : public UObject
{
public:
	uint8                                         Pad_28[0x8];                                       // 0x0028(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GizmoNilStateTarget">();
	}
	static class UGizmoNilStateTarget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGizmoNilStateTarget>();
	}
};
static_assert(alignof(UGizmoNilStateTarget) == 0x000008, "Wrong alignment on UGizmoNilStateTarget");
static_assert(sizeof(UGizmoNilStateTarget) == 0x000030, "Wrong size on UGizmoNilStateTarget");

// Class InteractiveToolsFramework.GizmoLambdaStateTarget
// 0x0088 (0x00B0 - 0x0028)
class UGizmoLambdaStateTarget final : public UObject
{
public:
	uint8                                         Pad_28[0x88];                                      // 0x0028(0x0088)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GizmoLambdaStateTarget">();
	}
	static class UGizmoLambdaStateTarget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGizmoLambdaStateTarget>();
	}
};
static_assert(alignof(UGizmoLambdaStateTarget) == 0x000008, "Wrong alignment on UGizmoLambdaStateTarget");
static_assert(sizeof(UGizmoLambdaStateTarget) == 0x0000B0, "Wrong size on UGizmoLambdaStateTarget");

// Class InteractiveToolsFramework.GizmoObjectModifyStateTarget
// 0x0030 (0x0058 - 0x0028)
class UGizmoObjectModifyStateTarget final : public UObject
{
public:
	uint8                                         Pad_28[0x30];                                      // 0x0028(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GizmoObjectModifyStateTarget">();
	}
	static class UGizmoObjectModifyStateTarget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGizmoObjectModifyStateTarget>();
	}
};
static_assert(alignof(UGizmoObjectModifyStateTarget) == 0x000008, "Wrong alignment on UGizmoObjectModifyStateTarget");
static_assert(sizeof(UGizmoObjectModifyStateTarget) == 0x000058, "Wrong size on UGizmoObjectModifyStateTarget");

// Class InteractiveToolsFramework.GizmoTransformChangeStateTarget
// 0x00A8 (0x00D0 - 0x0028)
class alignas(0x10) UGizmoTransformChangeStateTarget final : public UObject
{
public:
	uint8                                         Pad_28[0x28];                                      // 0x0028(0x0028)(Fixing Size After Last Property [ Dumper-7 ])
	TScriptInterface<class IToolContextTransactionProvider> TransactionManager;                                // 0x0050(0x0010)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, NativeAccessSpecifierPublic)
	uint8                                         Pad_60[0x70];                                      // 0x0060(0x0070)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GizmoTransformChangeStateTarget">();
	}
	static class UGizmoTransformChangeStateTarget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGizmoTransformChangeStateTarget>();
	}
};
static_assert(alignof(UGizmoTransformChangeStateTarget) == 0x000010, "Wrong alignment on UGizmoTransformChangeStateTarget");
static_assert(sizeof(UGizmoTransformChangeStateTarget) == 0x0000D0, "Wrong size on UGizmoTransformChangeStateTarget");
static_assert(offsetof(UGizmoTransformChangeStateTarget, TransactionManager) == 0x000050, "Member 'UGizmoTransformChangeStateTarget::TransactionManager' has a wrong offset!");

// Class InteractiveToolsFramework.TransformGizmoActor
// 0x0048 (0x0260 - 0x0218)
class ATransformGizmoActor final : public AGizmoActor
{
public:
	class UPrimitiveComponent*                    TranslateX;                                        // 0x0218(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPrimitiveComponent*                    TranslateY;                                        // 0x0220(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPrimitiveComponent*                    TranslateZ;                                        // 0x0228(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPrimitiveComponent*                    TranslateYZ;                                       // 0x0230(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPrimitiveComponent*                    TranslateXZ;                                       // 0x0238(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPrimitiveComponent*                    TranslateXY;                                       // 0x0240(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPrimitiveComponent*                    RotateX;                                           // 0x0248(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPrimitiveComponent*                    RotateY;                                           // 0x0250(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPrimitiveComponent*                    RotateZ;                                           // 0x0258(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TransformGizmoActor">();
	}
	static class ATransformGizmoActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATransformGizmoActor>();
	}
};
static_assert(alignof(ATransformGizmoActor) == 0x000008, "Wrong alignment on ATransformGizmoActor");
static_assert(sizeof(ATransformGizmoActor) == 0x000260, "Wrong size on ATransformGizmoActor");
static_assert(offsetof(ATransformGizmoActor, TranslateX) == 0x000218, "Member 'ATransformGizmoActor::TranslateX' has a wrong offset!");
static_assert(offsetof(ATransformGizmoActor, TranslateY) == 0x000220, "Member 'ATransformGizmoActor::TranslateY' has a wrong offset!");
static_assert(offsetof(ATransformGizmoActor, TranslateZ) == 0x000228, "Member 'ATransformGizmoActor::TranslateZ' has a wrong offset!");
static_assert(offsetof(ATransformGizmoActor, TranslateYZ) == 0x000230, "Member 'ATransformGizmoActor::TranslateYZ' has a wrong offset!");
static_assert(offsetof(ATransformGizmoActor, TranslateXZ) == 0x000238, "Member 'ATransformGizmoActor::TranslateXZ' has a wrong offset!");
static_assert(offsetof(ATransformGizmoActor, TranslateXY) == 0x000240, "Member 'ATransformGizmoActor::TranslateXY' has a wrong offset!");
static_assert(offsetof(ATransformGizmoActor, RotateX) == 0x000248, "Member 'ATransformGizmoActor::RotateX' has a wrong offset!");
static_assert(offsetof(ATransformGizmoActor, RotateY) == 0x000250, "Member 'ATransformGizmoActor::RotateY' has a wrong offset!");
static_assert(offsetof(ATransformGizmoActor, RotateZ) == 0x000258, "Member 'ATransformGizmoActor::RotateZ' has a wrong offset!");

// Class InteractiveToolsFramework.TransformGizmoBuilder
// 0x0098 (0x00C0 - 0x0028)
class UTransformGizmoBuilder final : public UInteractiveGizmoBuilder
{
public:
	uint8                                         Pad_28[0x98];                                      // 0x0028(0x0098)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TransformGizmoBuilder">();
	}
	static class UTransformGizmoBuilder* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTransformGizmoBuilder>();
	}
};
static_assert(alignof(UTransformGizmoBuilder) == 0x000008, "Wrong alignment on UTransformGizmoBuilder");
static_assert(sizeof(UTransformGizmoBuilder) == 0x0000C0, "Wrong size on UTransformGizmoBuilder");

// Class InteractiveToolsFramework.TransformGizmo
// 0x00E8 (0x0120 - 0x0038)
class alignas(0x10) UTransformGizmo final : public UInteractiveGizmo
{
public:
	class UTransformProxy*                        ActiveTarget;                                      // 0x0038(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_40[0x90];                                      // 0x0040(0x0090)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UPrimitiveComponent*>            ActiveComponents;                                  // 0x00D0(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	TArray<class UInteractiveGizmo*>              ActiveGizmos;                                      // 0x00E0(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_F0[0x10];                                      // 0x00F0(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UGizmoComponentAxisSource*              AxisXSource;                                       // 0x0100(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UGizmoComponentAxisSource*              AxisYSource;                                       // 0x0108(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UGizmoComponentAxisSource*              AxisZSource;                                       // 0x0110(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UGizmoTransformChangeStateTarget*       StateTarget;                                       // 0x0118(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TransformGizmo">();
	}
	static class UTransformGizmo* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTransformGizmo>();
	}
};
static_assert(alignof(UTransformGizmo) == 0x000010, "Wrong alignment on UTransformGizmo");
static_assert(sizeof(UTransformGizmo) == 0x000120, "Wrong size on UTransformGizmo");
static_assert(offsetof(UTransformGizmo, ActiveTarget) == 0x000038, "Member 'UTransformGizmo::ActiveTarget' has a wrong offset!");
static_assert(offsetof(UTransformGizmo, ActiveComponents) == 0x0000D0, "Member 'UTransformGizmo::ActiveComponents' has a wrong offset!");
static_assert(offsetof(UTransformGizmo, ActiveGizmos) == 0x0000E0, "Member 'UTransformGizmo::ActiveGizmos' has a wrong offset!");
static_assert(offsetof(UTransformGizmo, AxisXSource) == 0x000100, "Member 'UTransformGizmo::AxisXSource' has a wrong offset!");
static_assert(offsetof(UTransformGizmo, AxisYSource) == 0x000108, "Member 'UTransformGizmo::AxisYSource' has a wrong offset!");
static_assert(offsetof(UTransformGizmo, AxisZSource) == 0x000110, "Member 'UTransformGizmo::AxisZSource' has a wrong offset!");
static_assert(offsetof(UTransformGizmo, StateTarget) == 0x000118, "Member 'UTransformGizmo::StateTarget' has a wrong offset!");

// Class InteractiveToolsFramework.TransformProxy
// 0x0098 (0x00C0 - 0x0028)
class UTransformProxy final : public UObject
{
public:
	uint8                                         Pad_28[0x18];                                      // 0x0028(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bRotatePerObject;                                  // 0x0040(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSetPivotMode;                                     // 0x0041(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_42[0x1E];                                      // 0x0042(0x001E)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             SharedTransform;                                   // 0x0060(0x0030)(IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FTransform                             InitialSharedTransform;                            // 0x0090(0x0030)(IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TransformProxy">();
	}
	static class UTransformProxy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTransformProxy>();
	}
};
static_assert(alignof(UTransformProxy) == 0x000010, "Wrong alignment on UTransformProxy");
static_assert(sizeof(UTransformProxy) == 0x0000C0, "Wrong size on UTransformProxy");
static_assert(offsetof(UTransformProxy, bRotatePerObject) == 0x000040, "Member 'UTransformProxy::bRotatePerObject' has a wrong offset!");
static_assert(offsetof(UTransformProxy, bSetPivotMode) == 0x000041, "Member 'UTransformProxy::bSetPivotMode' has a wrong offset!");
static_assert(offsetof(UTransformProxy, SharedTransform) == 0x000060, "Member 'UTransformProxy::SharedTransform' has a wrong offset!");
static_assert(offsetof(UTransformProxy, InitialSharedTransform) == 0x000090, "Member 'UTransformProxy::InitialSharedTransform' has a wrong offset!");

// Class InteractiveToolsFramework.GizmoBaseTransformSource
// 0x0020 (0x0048 - 0x0028)
class UGizmoBaseTransformSource : public UObject
{
public:
	uint8                                         Pad_28[0x20];                                      // 0x0028(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GizmoBaseTransformSource">();
	}
	static class UGizmoBaseTransformSource* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGizmoBaseTransformSource>();
	}
};
static_assert(alignof(UGizmoBaseTransformSource) == 0x000008, "Wrong alignment on UGizmoBaseTransformSource");
static_assert(sizeof(UGizmoBaseTransformSource) == 0x000048, "Wrong size on UGizmoBaseTransformSource");

// Class InteractiveToolsFramework.GizmoComponentWorldTransformSource
// 0x0010 (0x0058 - 0x0048)
class UGizmoComponentWorldTransformSource final : public UGizmoBaseTransformSource
{
public:
	class USceneComponent*                        Component;                                         // 0x0048(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bModifyComponentOnTransform;                       // 0x0050(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_51[0x7];                                       // 0x0051(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GizmoComponentWorldTransformSource">();
	}
	static class UGizmoComponentWorldTransformSource* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGizmoComponentWorldTransformSource>();
	}
};
static_assert(alignof(UGizmoComponentWorldTransformSource) == 0x000008, "Wrong alignment on UGizmoComponentWorldTransformSource");
static_assert(sizeof(UGizmoComponentWorldTransformSource) == 0x000058, "Wrong size on UGizmoComponentWorldTransformSource");
static_assert(offsetof(UGizmoComponentWorldTransformSource, Component) == 0x000048, "Member 'UGizmoComponentWorldTransformSource::Component' has a wrong offset!");
static_assert(offsetof(UGizmoComponentWorldTransformSource, bModifyComponentOnTransform) == 0x000050, "Member 'UGizmoComponentWorldTransformSource::bModifyComponentOnTransform' has a wrong offset!");

// Class InteractiveToolsFramework.GizmoTransformProxyTransformSource
// 0x0008 (0x0050 - 0x0048)
class UGizmoTransformProxyTransformSource final : public UGizmoBaseTransformSource
{
public:
	class UTransformProxy*                        Proxy;                                             // 0x0048(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GizmoTransformProxyTransformSource">();
	}
	static class UGizmoTransformProxyTransformSource* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGizmoTransformProxyTransformSource>();
	}
};
static_assert(alignof(UGizmoTransformProxyTransformSource) == 0x000008, "Wrong alignment on UGizmoTransformProxyTransformSource");
static_assert(sizeof(UGizmoTransformProxyTransformSource) == 0x000050, "Wrong size on UGizmoTransformProxyTransformSource");
static_assert(offsetof(UGizmoTransformProxyTransformSource, Proxy) == 0x000048, "Member 'UGizmoTransformProxyTransformSource::Proxy' has a wrong offset!");

}

